#!/usr/bin/env python

from optparse import OptionParser
import matplotlib.pyplot as plt

p = OptionParser(usage='%prog [OPTION] FILE...',
                 description='plot timings from gpaw parallel timer.  '
                 'The timer dumps a lot of files called "timings.<...>.txt".  '
                 'This programme plots the contents of those files.  '
                 'Typically one would run "%prog timings.*.txt" to plot '
                 'timings on all cores.')
p.add_option('--interval', metavar='TIME1:TIME2',
             help='plot only timings within TIME1 and TIME2 '
             'after start of calculation.')
p.add_option('--nolegend', action='store_true',
             help='do not plot the separate legend figure')
p.add_option('--nointeractive', action='store_true',
             help='disable interactive legend')


opts, fnames = p.parse_args()


if opts.interval:
    plotstarttime, plotendtime = map(float, opts.interval.split(':'))
else:
    plotstarttime = 0
    plotendtime = None

fname = fnames[0]


# We will read/store absolute timings T1 and T2, which are probably 1e9.
# For the plot we want timings relative to some starting point.
class Call:
    def __init__(self, name, T1, level):
        self.name = name
        self.level = level  # nesting level
        self.T1 = T1
        self.T2 = None


fig = plt.figure()
ax = fig.add_subplot(111)
fig.subplots_adjust(left=0.08, right=.95, bottom=0.07, top=.95)
patch_name_p = []


class Function:
    thecolors = ['blue', 'green', 'red', 'cyan', 'magenta', 'yellow',
                 'darkred', 'indigo', 'springgreen', 'purple']
    thehatches = ['', '//', 'O', '*', 'o', r'\\', '.', '|']

    def __init__(self, name, num):
        self.name = name
        self.num = num
        self.color = self.thecolors[num % len(self.thecolors)]
        self.hatch = self.thehatches[num // len(self.thecolors)]
        self.bar = None
        self.calls = []


functions = {}
functionslist = []
maxlevel = 0
ongoing = []


with open(fname) as fd:
    for line in fd:
        line = line.strip()
        part1, part2, action = line.rsplit(' ', 2)
        tokens = part1.split(' ', 3)
        T = float(tokens[2])
        name = tokens[3]

        if action == 'started':
            level = len(ongoing)
            maxlevel = max(level, maxlevel)
            call = Call(name, T1=T, level=level)
            if name not in functions:
                function = Function(name, len(functions))
                functions[name] = function
                functionslist.append(function)
            ongoing.append(call)
        else:
            assert action == 'stopped', action
            call = ongoing.pop()
            assert name == call.name
            level = len(ongoing)
            call.T2 = T
            functions[name].calls.append(call)


# End any remaining ongoing calls:
for call in ongoing:
    call.T2 = T
    functions[call.name].calls.append(call)

Tstart = functionslist[0].calls[0].T1
if plotendtime is None:
    plotendtime = T - Tstart


thebars = {}
for name in sorted(functions):
    function = functions[name]
    plotcalls = []
    for call in function.calls:
        # Skip timings that fall out of the viewed interval:
        if call.T2 - Tstart < plotstarttime:
            continue
        if call.T1 - Tstart > plotendtime:
            continue
        plotcalls.append(call)

    # Shift: maxlevel, rank
    bar = ax.bar(left=[call.T1 - Tstart for call in plotcalls],
                 height=[1.0] * len(plotcalls),
                 width=[call.T2 - call.T1 for call in plotcalls],
                 bottom=[call.level for call in plotcalls],
                 color=function.color,
                 hatch=function.hatch,
                 edgecolor='black',
                 align='edge',
                 label=function.name)
    for child in bar.get_children():
        patch_name_p.append((child, name))
    thebars[name] = bar
    ax.axis(xmin=plotstarttime, xmax=plotendtime)


ncolumns = 1 + len(functionslist) // 32


if not opts.nolegend:
    namefig = plt.figure()
    nameax = namefig.add_subplot(111)

    for function in functionslist:
        nameax.bar([0], [0], [0], [0],
                   color=function.color, hatch=function.hatch,
                   label=function.name[:20])

    nameax.legend(handlelength=2.5,
                  labelspacing=0.0,
                  fontsize='large',
                  ncol=ncolumns,
                  mode='expand',
                  frameon=True,
                  loc='best')


if not opts.nointeractive:
    default_text = 'Click on a patch to get the name'
    p = fig.subplotpars

    # Create interactive axes
    iax = fig.add_axes((p.left, p.top, p.right - p.left, 1 - p.top),
                       facecolor=fig.get_facecolor())
    ibg = iax.patch
    for s in iax.get_children():
        if s != ibg:
            s.set_visible(False)
    itext = iax.text(0.5, 0.5, default_text, va='center', ha='center',
                     transform=iax.transAxes)

    def print_name_event(event):
        text = default_text
        # Do action based on the chosen tool
        # tb = fig.canvas.manager.toolbar
        # if tb.mode != '':
        #     return
        for patch, name in patch_name_p:
            if patch.contains(event)[0]:
                text = name
                break
        itext.set_text(text)
        # The next lines can be replace with
        # fig.canvas.draw()
        # but it'll be very slow
        iax.draw_artist(ibg)
        iax.draw_artist(itext)

        canvas = fig.canvas
        if hasattr(canvas, 'update'):
            canvas.update()  # matplotlib 0.x
        else:
            canvas.draw()  # matplotlib 2.x
        canvas.flush_events()

    fig.canvas.mpl_connect('button_press_event', print_name_event)


plt.show()
