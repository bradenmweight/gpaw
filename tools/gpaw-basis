#!/usr/bin/env python
# Emacs: treat this as -*- python -*-

import sys
from optparse import OptionParser

description = 'Generate LCAO basis sets for the specified elements.'

parser = OptionParser(usage='%prog [options] [elements]',
                      version='%prog 0.1', description=description)
parser.add_option('-n', '--name', default=None, metavar='<name>',
                  help='name of generated basis files')
parser.add_option('-t', '--type', default='dzp', metavar='<type>',
                  help='type of basis.  For example: sz, dzp, qztp, '+
                  '4z3p.  [default: %default]')
parser.add_option('-E', '--energy-shift', metavar='<energy>', type='float',
                  default=.1,
                  help='use given energy shift to determine cutoff')
parser.add_option('-T', '--tail-norm', metavar='<norm>', type='string',
                  default='0.16,0.3,0.6', dest='tailnorm',
                  help='use the given fractions to define the split'+
                  '-valence cutoffs.  Default: [%default]')
parser.add_option('-g', '--non-relativistic-guess', action='store_true',
                  help='Run non-scalar relativistic AE calculation for '
                  'initial guess')
#parser.add_option('-D', '--energy-derivative', action='store_true',
#                  dest='derivative',
#                  help='include derivative of atomic orbital with respect '+
#                  'to confinement potential inner cutoff as second '+
#                  'basis function')
parser.add_option('-P', '--plot', action='store_true',
                  help='plot basis functions')
parser.add_option('-N', '--no-files', action='store_true',
                  help='Do not write basis function files')
parser.add_option('-X', '--exclude', action='store_true',
                  help='generate basis sets for all g2 elements, excluding '+
                  'those specified')
parser.add_option('--rcut-max', type='float', default=16., metavar='<rcut>',
                  help='max cutoff for confined atomic orbitals.  This '+
                  'option has no effect on orbitals with smaller cutoff '+
                  '[default/Bohr: %default]')
parser.add_option('--rcut-pol-rel', type='float', default=1.0,
                  metavar='<rcut>',
                  help='polarization function cutoff relative to largest'+
                  ' single-zeta cutoff [default: %default]')
parser.add_option('--rchar-pol-rel', type='float', default=None,
                  metavar='<rchar>',
                  help='characteristic radius of Gaussian when not using '+
                  'interpolation scheme, relative to rcut')
parser.add_option('--gaussians', type='int', metavar='<n>',
                  help='use the specified number of Gaussians for '+
                  'polarization function interpolation')
parser.add_option('--vconf-amplitude', type='float', default=12.,
                  metavar='<alpha>',
                  help='set proportionality constant of smooth confinement '+
                  'potential [default: %default]')
parser.add_option('--vconf-rstart-rel', type='float', default=.6,
                  metavar='<ri/rc>',
                  help='set inner cutoff for smooth confinement potential '+
                  'relative to hard cutoff [default: %default]')
parser.add_option('--vconf-sharp-confinement', action='store_true',
                  help='use sharp rather than smooth confinement potential')
parser.add_option('--debug', action='store_true',
                  help='use gpaw-DEBUG mode')

opts, args = parser.parse_args()

if __name__ == '__main__' and len(args) == 0 and not opts.exclude:
    parser.print_help()
    sys.exit(0)

from gpaw.atom.generator import Generator
from gpaw.atom.basis import BasisMaker
from gpaw.atom.all_electron import ConvergenceError
from gpaw.atom import polarization

if opts.exclude: # Invert selection of elements
    from ase.data import molecules
    # If the user specifies N:<reference_system> then remember that
    # because we don't want to exclude those
    special_args = [arg for arg in args if ':' in arg]

    # List of the actual element names in argv
    elements = [arg.split(':')[0] for arg in args]
    inverted_args = [arg for arg in molecules.atoms if not arg in elements]
    inverted_args.remove('Mg') # g2 contains no Mg reference systems

    # Now re-add those we remembered earlier
    inverted_args.extend(special_args)

    args = inverted_args
    if len(args) == 0:
        print 'Another job well done!'
        sys.exit(0)

bad_density_warning = """\
Bad initial electron density guess!  Try rerunning the basis generator
with the '-g' parameter to run a separate non-scalar relativistic
all-electron calculation and use its resulting density as an initial
guess."""

very_bad_density_warning = """\
Could not generate non-scalar relativistic electron density guess,
or non-scalar relativistic guess was not good enough for the scalar
relativistic calculation.  You probably have to use the Python interface
to the basis generator in gpaw.atom.basis directly and choose very
smart parameters."""

def parse_basis_name(name):
    """Parse any basis type identifier: 'sz', 'dzp', 'qztp', '4z3p', ... """
    letter2number = {'s' : 1, 'd' : 2, 't' : 3, 'q' : 4}
    number2letter = 'Xsdtq56789'

    newchars = ['', 'z', '', 'p']
    zetacount = letter2number.get(name[0])
    if zetacount is None:
        zetacount = int(name[0])
    assert name[1] == 'z'
    newchars[0] = number2letter[zetacount]
    if len(name) == 2:
        polcount = 0
        newchars[-1] = ''
    elif len(name) == 3:
        assert name[-1] == 'p'
        polcount = 1
    else:
        assert len(name) == 4 and name[-1] == 'p'
        polcount = letter2number.get(name[2])
        if polcount is None:
            polcount = int(name[2])
        newchars[2] = number2letter[polcount]
    return zetacount, polcount, ''.join(newchars)

def main():
    zetacount, polcount, basistype = parse_basis_name(opts.type)
    referencefiles = [None] * len(args)
    reference_atom_indices = [None] * len(args)
    if polcount > 0:
        symbols = []
        for i, arg in enumerate(args):
            # Parse argument as <symbol>:<reference-file>:<nuclear index>.
            symbol_and_file = arg.split(':')
            symbol = symbol_and_file[0]
            symbols.append(symbol)
            if len(symbol_and_file) > 1:
                referencefiles[i] = symbol_and_file[1] # filename
            if len(symbol_and_file) == 3:
                reference_atom_indices[i] = int(symbol_and_file[2])
    else:
        symbols = args

    if opts.name is not None:
        name = '%s.%s' % (opts.name, basistype)
    else:
        name = basistype

    for symbol, referencefile, referenceindex in zip(symbols, referencefiles,
                                                     reference_atom_indices):
        try:
            bm = BasisMaker(symbol, name, gtxt=None,
                            non_relativistic_guess=opts.non_relativistic_guess)
        except ConvergenceError:
            if opts.non_relativistic_guess:
                print >> sys.stderr, very_bad_density_warning
                import traceback
                traceback.print_exc()
            else:
                print >> sys.stderr, bad_density_warning
            continue
        
        if opts.no_files:
            figfile = None
        else:
            figfile = '%s.%s.png' % (symbol, name)
        tailnorm = [float(norm) for norm in opts.tailnorm.split(',')]
        vconf_args = None
        if not opts.vconf_sharp_confinement:
            vconf_args = opts.vconf_amplitude, opts.vconf_rstart_rel
        
        basis = bm.generate(zetacount, polcount,
                            tailnorm=tailnorm,
                            energysplit=opts.energy_shift,
                            referencefile=referencefile,
                            referenceindex=referenceindex,
                            rcutpol_rel=opts.rcut_pol_rel,
                            rcutmax=opts.rcut_max,
                            ngaussians=opts.gaussians,
                            rcharpol_rel=opts.rchar_pol_rel,
                            vconf_args=vconf_args)
        
        if opts.plot:
            bm.plot(basis, title=referencefile, filename=figfile)
        if not opts.no_files:
            basis.write_xml()
    if opts.plot and opts.no_files:
        import pylab
        pylab.show()

if __name__ == '__main__':    
    main()
